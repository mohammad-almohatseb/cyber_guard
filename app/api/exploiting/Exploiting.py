import asyncio
import logging
from fastapi import HTTPException
from app.api.models.information import WebInfoGatheringModel, NetworkInfoGathering
from app.api.models.vuln_assessment import WebVulnerabilityAssessmentModel, NetworkVulnerabilityAssessmentModel
from app.api.models.vuln_exploiting import NetworkVulnerabilityExploitingModel, WebVulnerabilityExploitingModel
from app.api.exploiting.network.vsftpd_exploit import exploit_vsftpd_and_get_credentials
from app.api.exploiting.network.vnc_exploit import run_vnc_login_console
from app.api.exploiting.network.apache_tomact import exploit_tomcat_mgr
from app.api.exploiting.web.sql_injection import run_sqlmap

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Exploiting:
    def __init__(self):
        pass

    @staticmethod
    async def get_network_data(ip_address: str):
        network_data = await NetworkVulnerabilityAssessmentModel.find_one(NetworkVulnerabilityAssessmentModel.target == ip_address)
        return network_data

    async def network_vulnerability_exploiting(self, ip_address: str):
        network_data = await self.get_network_data(ip_address)

        if network_data is None:
            raise HTTPException(status_code=404, detail="Network data not found")

        detected_services = network_data.detected_services_data or []
        vsftpd_exploiting_data = []
        vnc_exploiting_data = []
        apache_tomcat_data = []

        for item in detected_services:
            target = item.get("target")
            service = item.get("service", "").lower()

            if "ftp vsftpd 2.3.4" in service:
                result = await exploit_vsftpd_and_get_credentials(target)
                if result:
                    vsftpd_exploiting_data.append(result)

            if "vnc vnc (protocol 3.3)" in service:
                result = await run_vnc_login_console(target)
                if result:
                    vnc_exploiting_data.append({
                        "target": target,
                        "password": result
                    })

            normalized_service = " ".join(service.split())
            if "http apache tomcat/coyote jsp engine 1.1" in normalized_service:
                result = await exploit_tomcat_mgr(target)
                if result:
                    apache_tomcat_data.append(result)

        network_vuln_exploiting = NetworkVulnerabilityExploitingModel(
            target=ip_address,
            vsftpd_exploiting_data=vsftpd_exploiting_data,
            vnc_exploiting_data=vnc_exploiting_data,
            apache_tomcat_data=apache_tomcat_data
        )
        await network_vuln_exploiting.save()

    async def get_web_data(self, domain: str):
        web_data = await WebInfoGatheringModel.find_one(WebInfoGatheringModel.target == domain)
        return web_data

    async def web_vulnerability_exploiting(self, domain: str):
        web_data = await self.get_web_data(domain)

        if web_data is None:
            raise HTTPException(status_code=404, detail="Web data not found")

        target = web_data.target
        archive_urls = web_data.archive_urls or []
        # injectable_urls = []

        # for obj in archive_urls:
        #     urls = obj.get("injectable_urls", [])
        #     injectable_urls.extend(urls)
            
        # injectable_urls = [url for url in injectable_urls if url.startswith("http") and "=" in url]
        # all_sql_data = []
        # sqlmap_results = await run_sqlmap(injectable_urls)
        
        # for result in sqlmap_results:
        #     all_sql_data.append(result)
        
        injectable_urls = ['http://testphp.vulnweb.com?cid=']
        
        all_sql_data = await run_sqlmap(injectable_urls)

        web_exploitation = WebVulnerabilityExploitingModel(
            target=target,
            sql_injection_data=all_sql_data
        )
        await web_exploitation.insert()
