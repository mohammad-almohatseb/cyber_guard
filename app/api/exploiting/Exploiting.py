import asyncio
import logging
from fastapi import HTTPException
from app.api.models.information import WebInfoGatheringModel
from app.api.models.vuln_assessment import WebVulnerabilityAssessmentModel, NetworkVulnerabilityAssessmentModel
from app.api.models.vuln_exploiting import NetworkVulnerabilityExploitingModel, WebVulnerabilityExploitingModel
from app.api.exploiting.network.vsftpd_exploit import exploit_vsftpd_and_get_credentials
from app.api.exploiting.network.vnc_exploit import run_vnc_login_console
from app.api.exploiting.network.apache_tomact import exploit_tomcat_mgr
from app.api.exploiting.web.xss_exploit import main as xss_main
from app.api.exploiting.web.redirect_exploit import test_urls_for_redirect
from app.api.exploiting.web.sql_exploit import sql_exploits

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Exploiting:
    def __init__(self):
        pass

    async def get_network_data(self, ip_address: str):
        return await NetworkVulnerabilityAssessmentModel.find_one(
            NetworkVulnerabilityAssessmentModel.target == ip_address
        )

    async def network_vulnerability_exploiting(self, ip_address: str):
        network_data = await self.get_network_data(ip_address)
        if network_data is None:
            raise HTTPException(status_code=404, detail="Network data not found")

        detected_services = network_data.detected_services_data or []
        vsftpd_exploiting_data, vnc_exploiting_data, apache_tomcat_data = [], [], []

        for item in detected_services:
            target = item.get("target")
            service = item.get("service", "").lower()

            if "ftp vsftpd 2.3.4" in service:
                result = await exploit_vsftpd_and_get_credentials(target)
                if result:
                    vsftpd_exploiting_data.append(result)

            if "vnc vnc (protocol 3.3)" in service:
                result = await run_vnc_login_console(target)
                if result:
                    vnc_exploiting_data.append({"target": target, "password": result})

            normalized_service = " ".join(service.split())
            if "http apache tomcat/coyote jsp engine 1.1" in normalized_service:
                result = await exploit_tomcat_mgr(target)
                if result:
                    apache_tomcat_data.append(result)

        network_vuln_exploiting = NetworkVulnerabilityExploitingModel(
            target=ip_address,
            vsftpd_exploiting_data=vsftpd_exploiting_data,
            vnc_exploiting_data=vnc_exploiting_data,
            apache_tomcat_data=apache_tomcat_data
        )
        await network_vuln_exploiting.save()

    async def get_web_data(self, domain: str):
        return await WebVulnerabilityAssessmentModel.find_one(
            WebVulnerabilityAssessmentModel.target == domain
        )

    async def get_web_info_data(self, domain: str):
        return await WebInfoGatheringModel.find_one(
            WebInfoGatheringModel.target == domain
        )

    async def web_vulnerability_exploiting(self, domain: str):
        web_data = await self.get_web_data(domain)
        if web_data is None:
            raise HTTPException(status_code=404, detail="Web data not found")

        target = web_data.target


        # xss_info = web_data.all_expected_vulns.get("XSS", []) if web_data.all_expected_vulns else []
        # xss_urls = [item.get("url") for item in xss_info if item.get("url")]

        # logger.info(f"Running XSS Exploiting for target: {target}")
        # xss_results = await xss_main(xss_urls)
        # logger.info(f"XSS Exploiting completed for target: {target}")




        web_info_data = await self.get_web_info_data(domain)
        if web_info_data is None:
            raise HTTPException(status_code=404, detail="Web info data not found")
        
        
        # archive_urls = getattr(web_info_data, "archive_urls", []) or []

        # redirect_urls = []
        # for obj in archive_urls:
        #     urls = obj.get("redirect_urls", [])
        #     if isinstance(urls, list):
        #      redirect_urls.extend(urls)
        #     else:
        #       logger.warning(f"Unexpected type for redirect_urls in archive: {type(urls)}")

        # logger.info(f"Extracted {len(redirect_urls)} redirect URLs from archive data")

        # if len(redirect_urls) == 0:
        #    logger.warning("No redirect URLs found to test.")

        # logger.info(f"Running Redirect Exploiting for target: {target}")
        # redirect_results = await test_urls_for_redirect(redirect_urls)

        # logger.info(f"Redirect Exploiting completed for target: {target}")


        # logger.info(f"Vulnerable URLs found: {len(redirect_results.get('vulnerable_urls', []))}")
        # for url in redirect_results.get('vulnerable_urls', []):
        #     logger.info(f"[VULNERABLE] {url}")



        sql_info = web_data.all_expected_vulns.get("SQLI", []) if web_data.all_expected_vulns else []
        sql_urls = [item.get("url") for item in sql_info if item.get("url")]

        # Limit to only 3 URLs
        sql_urls = sql_urls[:1]

        logger.info(f"Running SQLI Exploiting for target: {target}")

        sql_results = []
        for url in sql_urls:
           result = await sql_exploits(url)
           sql_results.extend(result)

        logger.info(f"SQLI Exploiting completed for target: {target}")



    
        web_exploitation = WebVulnerabilityExploitingModel(
            target=target,
            # xss_results=xss_results,
            # open_redirect_results=redirect_results.get("open_redirect_results", []),
            sql_results=sql_results
        )
        await web_exploitation.insert()
