import asyncio
import subprocess
import httpx
import logging

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)

async def run_subprocess(command, input_data=None):
    proc = await asyncio.create_subprocess_exec(
        *command,
        stdin=asyncio.subprocess.PIPE if input_data else None,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await proc.communicate(input=input_data.encode() if input_data else None)
    if proc.returncode != 0:
        raise RuntimeError(f"Command {' '.join(command)} failed: {stderr.decode().strip()}")
    return stdout.decode()

async def fetch_redirect(url: str, client: httpx.AsyncClient):
    try:
        resp = await client.head(url, follow_redirects=False, timeout=10)
        location = resp.headers.get("location", "")
        return url, location
    except Exception as e:
        logger.error(f"Error checking URL {url}: {e}")
        return url, None

async def test_urls_for_redirect(input_urls: list[str]):
    logger.info(f"Received {len(input_urls)} URLs for open redirect testing.")

    # Step 1: Inject payloads into URLs using qsreplace
    logger.info("Injecting payloads into URLs...")
    injected_urls = []
    for url in input_urls:
        try:
            injected = await run_subprocess(["qsreplace", "http://evil.com"], input_data=url)
            injected_urls.append(injected.strip())
        except Exception as e:
            logger.warning(f"qsreplace failed on {url}: {e}")
    logger.info(f"Injected payloads into {len(injected_urls)} URLs")

    # Step 2: Test injected URLs for direct open redirects
    logger.info("Testing injected URLs for redirects...")
    vulnerable_urls = []
    async with httpx.AsyncClient(follow_redirects=False) as client:
        results = await asyncio.gather(*[fetch_redirect(url, client) for url in injected_urls])

    for url, location in results:
        if location == "http://evil.com":
            logger.warning(f"{url} [VULNERABLE]")
            vulnerable_urls.append(url)
    logger.info(f"Direct check found {len(vulnerable_urls)} vulnerable URLs")

    # Step 3: Since we removed OpenRedireX, just reuse direct vulnerable URLs here
    open_redirect_results = vulnerable_urls.copy()

    logger.info(f"Open redirect results count: {len(open_redirect_results)}")

    # Return all relevant data
    return {
        "input_urls": input_urls,
        "injected_urls": injected_urls,
        "vulnerable_urls": vulnerable_urls,
        "open_redirect_results": open_redirect_results,
    }
