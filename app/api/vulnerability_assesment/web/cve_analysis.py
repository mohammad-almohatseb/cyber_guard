import logging
import asyncio
import httpx
import sys

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

async def normalize_input(raw_input: str) -> str:
    return " ".join(raw_input.strip().replace("/", " ").lower().split())

async def fetch_cves(session: httpx.AsyncClient, keyword: str) -> list[dict]:
    """Async fetch from NVD API."""
    params = {
        "keywordSearch": keyword,
        "resultsPerPage": 5,
        "startIndex": 0
    }
    try:
        response = await session.get(NVD_API_URL, params=params, timeout=50)
        if response.status_code != 200:
            logger.error(f"Failed to fetch CVEs for '{keyword}', status code: {response.status_code}")
            return []
        return response.json().get("vulnerabilities", [])
    except Exception as e:
        logger.error(f"Error while contacting NVD for '{keyword}': {e}")
        return []

# main cve function
async def search_cves(tech_string: str, subdomain) -> list[dict]:
    """Normalize input, try exact + fallback CVE search asynchronously."""
    if not isinstance(tech_string, str) or tech_string.strip().lower() == "unknown":
        logger.info(" Input is 'Unknown' or not a valid string. Skipping...")
        return []

    normalized = await normalize_input(tech_string)
    logger.info(f"Searching NVD for: {normalized}")

    async with httpx.AsyncClient() as session:
        cves = await fetch_cves(session, normalized)

        if not cves and " " in normalized:
            fallback = normalized.split(" ")[0]
            logger.warning(f"No exact match. Trying broader search for: {fallback}")
            cves = await fetch_cves(session, fallback)

        if not cves:
            logger.info(" No CVEs found.")
            return []

    return cves

# server cve function
async def search_cves_server(tech_string: str, subdomain):
    cves = await search_cves(tech_string, subdomain)
    results = {}
    for cve in cves:
        cve_data = cve.get("cve", {})
        cve_id = cve_data.get("id", "N/A")
        desc_list = cve_data.get("descriptions", [])
        description = desc_list[0].get("value", "No description.") if desc_list else "No description."

        # Extract CVSS score (prefer v3.1 over v2)
        metrics = cve_data.get("metrics", {})
        cvss = metrics.get("cvssMetricV31", [{}])[0].get("cvssData", {}).get("baseScore") \
            or metrics.get("cvssMetricV2", [{}])[0].get("cvssData", {}).get("baseScore")

        logger.info(f"- {cve_id}: {description} | Severity: {cvss if cvss else 'N/A'}")

        results.update({
            "subdomain": subdomain,
            "server": tech_string,
            "id": cve_id,
            "description": description,
            "cvss_score": cvss
        })

    return results

# service cve function 
async def search_cves_open_ports(tech_string: str, domain):
    cves = await search_cves(tech_string, domain)
    results = {}
    for cve in cves:
        cve_data = cve.get("cve", {})
        cve_id = cve_data.get("id", "N/A")
        desc_list = cve_data.get("descriptions", [])
        description = desc_list[0].get("value", "No description.") if desc_list else "No description."

        # Extract CVSS score (prefer v3.1 over v2)
        metrics = cve_data.get("metrics", {})
        cvss = metrics.get("cvssMetricV31", [{}])[0].get("cvssData", {}).get("baseScore") \
            or metrics.get("cvssMetricV2", [{}])[0].get("cvssData", {}).get("baseScore")

        logger.info(f"- {cve_id}: {description} | Severity: {cvss if cvss else 'N/A'}")

        results.update({
            "domain": domain,
            "service": tech_string,
            "id": cve_id,
            "description": description,
            "cvss_score": cvss
        })

    return results

# waf cve function
async def search_cves_server_waf(tech_string: str, subdomain, has_waf):
    if not has_waf:
        return {
            "subdomain": subdomain,
            "has_waf": has_waf,
            "description": "Without a WAF, the app is more vulnerable to attacks like SQLi, XSS, and DDoS due to lack of initial request filtering."
        }

    cves = await search_cves(tech_string, subdomain)
    results = {}
    for cve in cves:
        cve_data = cve.get("cve", {})
        cve_id = cve_data.get("id", "N/A")
        desc_list = cve_data.get("descriptions", [])
        description = desc_list[0].get("value", "No description.") if desc_list else "No description."

        # Extract CVSS score (prefer v3.1 over v2)
        metrics = cve_data.get("metrics", {})
        cvss = metrics.get("cvssMetricV31", [{}])[0].get("cvssData", {}).get("baseScore") \
            or metrics.get("cvssMetricV2", [{}])[0].get("cvssData", {}).get("baseScore")

        logger.info(f"- {cve_id}: {description} | Severity: {cvss if cvss else 'N/A'}")

        results.update({
            "subdomain": subdomain,
            "has_waf": has_waf,
            "waf_name": tech_string,
            "id": cve_id,
            "description": description,
            "cvss_score": cvss
        })

    return results


