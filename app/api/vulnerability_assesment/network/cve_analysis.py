import logging
import asyncio
import subprocess
import re

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Normalize input
async def normalize_input(raw_input: str) -> str:
    return " ".join(raw_input.strip().replace("/", " ").lower().split())

# Clean service string for searchsploit
def clean_service_for_searchsploit(service_string: str) -> str:
    service_string = re.sub(r"\(.*?\)", "", service_string.lower())
    cleaned = re.sub(r"[^a-zA-Z0-9.]+", " ", service_string)
    cleaned = " ".join(cleaned.split())

    ignored_words = {"protocol", "engine", "http", "apache", "linux", "ubuntu", "from", "service", "detection"}

    tokens = [t for t in cleaned.split() if t not in ignored_words]

    version_pattern = re.compile(r"\d+(\.\d+){1,2}[a-z0-9\-]*")

    for i, token in enumerate(tokens):
        if version_pattern.search(token) and i > 0:
            return f"{tokens[i - 1]} {token}"

    if tokens:
        return tokens[0]  # fallback to first real token like "vsftpd", "openssh"

    return service_string
# Search exploits using searchsploit
async def search_exploits(keyword: str) -> list[dict]:
    try:
        result = subprocess.run(["searchsploit", keyword], capture_output=True, text=True, timeout=15)
        if result.returncode != 0 or not result.stdout.strip():
            logger.warning(f"No exploits found for: {keyword}")
            return []

        exploits = []
        for line in result.stdout.splitlines():
            if "|" in line and not line.startswith("/"):
                parts = [p.strip() for p in line.split("|")]
                if len(parts) >= 2:
                    title, path = parts[0], parts[1]
                    # Get CVE ID if possible
                    cve_result = subprocess.run(["searchsploit", "-p", path], capture_output=True, text=True)
                    cve_match = re.search(r"CVE-\d{4}-\d+", cve_result.stdout)
                    cve_id = cve_match.group(0) if cve_match else "N/A"
                    exploits.append({"title": title, "path": path, "cve_id": cve_id})
        return exploits

    except Exception as e:
        logger.error(f"Error running searchsploit for '{keyword}': {e}")
        return []

# Main CVE search function
async def search_cves(tech_string: str, host) -> list[dict]:
    if not isinstance(tech_string, str) or tech_string.strip().lower() in ("unknown", "timeout"):
        logger.info("Input is 'Unknown', 'Timeout', or invalid. Skipping...")
        return []

    normalized = await normalize_input(tech_string)
    logger.info(f"Original normalized input: {normalized}")

    keyword = clean_service_for_searchsploit(normalized)
    logger.info(f"Searching exploits for '{keyword}'")

    exploits = await search_exploits(keyword)
    return exploits

# Search CVEs related to operating system
async def search_cves_os(tech_string: str, host):
    exploits = await search_cves(tech_string, host)
    results = []
    for e in exploits:
        results.append({
            "target": host,
            "os": tech_string,
            "id": e.get("cve_id"),
            "description": e.get("title"),
            "exploit_path": e.get("path")
        })
    return results

# Search CVEs related to services
async def search_cves_service(tech_string: str, host):
    exploits = await search_cves(tech_string, host)
    results = []
    for e in exploits:
        results.append({
            "target": host,
            "service": tech_string,
            "id": e.get("cve_id"),
            "description": e.get("title"),
            "exploit_path": e.get("path")
        })
    return results

# Search CVEs related to WAFs
async def search_cves_waf(firewall_detected: str, host):
    if not firewall_detected:
        return [{
            "target": host,
            "has_waf": "No",
            "description": "Without a WAF, the system is more vulnerable to attacks like SQLi, XSS, and DDoS due to lack of request filtering."
        }]

    exploits = await search_cves(firewall_detected, host)
    results = []
    for e in exploits:
        results.append({
            "target": host,
            "waf_name": firewall_detected,
            "id": e.get("cve_id"),
            "description": e.get("title"),
            "exploit_path": e.get("path")
        })
    return results
