import asyncio
import logging
from fastapi import HTTPException
from app.api.models.information import WebInfoGatheringModel, NetworkInfoGathering
from app.api.models.vuln_assessment import WebVulnerabilityAssessmentModel, NetworkVulnerabilityAssessmentModel

from app.api.vulnerability_assesment.web.cve_analysis import (
    search_cves_server,
    search_cves_server_waf,
    search_cves_open_ports,
)
from app.api.vulnerability_assesment.web.directory_analysis import check_urls_for_common_paths
from app.api.vulnerability_assesment.web.http_headers_analysis import assess_http_headers
from app.api.vulnerability_assesment.web.cert_checker import check_certificate
from app.api.vulnerability_assesment.web.input_validation import scan_input_validation

from app.api.vulnerability_assesment.network.cve_analysis import (
    search_cves_service,
    search_cves_os,
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilityAssessment:
    def __init__(self):
        pass

    async def get_web_data(self, domain: str):
        web_data = await WebInfoGatheringModel.find_one(WebInfoGatheringModel.target == domain)
        return web_data

    async def web_vulnerability_assesment(self, domain: str):
        web_data: WebInfoGatheringModel = await self.get_web_data(domain)
        logger.debug(f"web_data:  {web_data}")

        if web_data is None:
            raise HTTPException(status_code=404, detail="Web data not found")

        subdomains = web_data.subdomains or []

        # Run service CVE checks concurrently
        service_tasks = [
            search_cves_open_ports(item.get("service", []), item.get("domain"))
            for item in (web_data.open_ports or [])
        ]
        service_cve_data = await asyncio.gather(*service_tasks)

        # Run WAF CVE checks concurrently
        waf_tasks = [
            search_cves_server_waf(item.get("waf_name", []), item.get("subdomain"), item.get("has_waf"))
            for item in (web_data.waf_detections or [])
        ]
        waf_cve_data = await asyncio.gather(*waf_tasks)

        # Run server CVE checks concurrently
        server_tasks = [
            search_cves_server(item.get("server", []), item.get("subdomain"))
            for item in (web_data.server_info or [])
        ]
        server_cve_data = await asyncio.gather(*server_tasks)

        # Directory analysis concurrently
        directory_tasks = [
            check_urls_for_common_paths([item])
            for item in (web_data.directories or [])
        ]
        directory_analysis_data = await asyncio.gather(*directory_tasks)

        # HTTP headers analysis concurrently
        headers_tasks = [
            assess_http_headers(item.get("security_headers"), item.get("observed_headers"), item.get("subdomain"))
            for item in (web_data.https_headers or [])
        ]
        https_headers_data = await asyncio.gather(*headers_tasks)

        # Certificate checking concurrently
        certificate_tasks = [
            check_certificate(
                item.get("subdomain"),
                item.get("has_tls"),
                item.get("start_date"),
                item.get("expire_date"),
                item.get("issuer"),
            )
            for item in (web_data.certificate_details or [])
        ]
        certificate_checked = await asyncio.gather(*certificate_tasks)

        # Input validation concurrently
        input_validation_results = await asyncio.gather(
            *(scan_input_validation(item) for item in subdomains)
        )
        logger.debug(f"input_validation_results: {input_validation_results}")

        # Store results in DB
        web_vuln_assessment = WebVulnerabilityAssessmentModel(
            target=domain,
            server_cve_data=server_cve_data,
            service_cve_data=service_cve_data,
            waf_cve_data=waf_cve_data,
            dirictory_analysis_data=directory_analysis_data,
            https_headers_data=https_headers_data,
            certificate_data=certificate_checked,
            input_validation_data=input_validation_results,
        )
        await web_vuln_assessment.save()

    @staticmethod
    async def get_network_data(ip_address: str):
        network_data = await NetworkInfoGathering.find_one(NetworkInfoGathering.target == ip_address)
        return network_data

    async def network_vulnerability_assesment(self, ip_address: str):
        network_data = await self.get_network_data(ip_address)

        if network_data is None:
            raise HTTPException(status_code=404, detail="Network data not found")

        target = network_data.target
        alive_hosts = network_data.alive_hosts or []

        # Service CVE detection concurrently
        service_tasks = []
        for item in (network_data.detected_services or []):
            host = item.get("host")
            services = item.get("services", [])
            for service_entry in services:
                service_tasks.append(
                    search_cves_service(service_entry.get("service"), host)
                )
        detected_services_data = await asyncio.gather(*service_tasks)

        # OS CVE detection concurrently
        os_tasks = []
        for item in (network_data.os_detection or []):
            os_info = item.get("os_info", "").lower()
            if "unknown" in os_info or "time out" in os_info:
                continue
            os_tasks.append(search_cves_os(os_info, item.get("host")))

        os_results = await asyncio.gather(*os_tasks)
        os_detection_data = [res for res in os_results if res]

        # Store in DB
        network_vuln_assessment = NetworkVulnerabilityAssessmentModel(
            target=target,
            os_detection_data=os_detection_data,
            detected_services_data=detected_services_data,
        )
        await network_vuln_assessment.save()
